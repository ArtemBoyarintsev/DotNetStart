Производство Легковых Автомобилей.

Автомобиль состоит из корпуса и двигателя. Существуют производтели корпуса и двигателей.
Сделанные детали помещаются на свой склад. Сборщик авто берет корпус и двигатель и собирает авто.

В произвольные моменты времени генерируется покупатель. 
Он обращается в Магазин, и если в магазине есть автомобиль, то он его забирает. 
В противном случае, заказывает его на фабрике и ждет, пока автомобиль не появится  в магазине. 
Чтобы автомобиль мог оказаться в магазине, периодически просыпается менеджер магазина и смотрит на количество автомобилей в магазине.
Если это число меньше необходимого, то он также заказывает автомобили с фабрики.

Моя реализация.
Я создал типизированные классы Producer<T> и Storage<T>. 
Производитель непрерывно поставляет свою продукцию T на склад T.
Склад имеет ограничения по вместимости деталей, и в случае если производитель не может положить еще одну деталь,
то он засыпает до тех пор, пока не освободится место. 
Фабрика получает запросы от покуателя и от менеджера магазина по заказу автомобилей и заставляет
Сборищка (Assembler) собрать из деталей новый автомобиль. 

Сборщик реализован довольно просто. Есть работники. Они все находится в ThreadPool(написанный самостоятельно).
Когда Фабрика получает заказ, она, через специальный объект AssemblerController отправляет работу по сборке
в ThreadPool.
Работники  запускаются лишь однажды  и постоянно "достают" работу из специальной блокирующейся очереди(BlockingQueue).
Блокирующая очередь - это обычная очередь, которая 
во-первых, потокобезопасна;
во-вторых, если поток достает из очереди что - то, а очередь пуста, то поток уснет до тех пор, 
    пока в очереди не появится что - нибудь.
в-третьих, если поток пытается положить в очередь что - то, а очередь полна, то поток засыпает до тех пор, пока не освободится
    место.
Также все происходящее пишется в Log.txt файл.
Остановить работу фабрики можно нажав 's'.
